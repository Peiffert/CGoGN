std::string ShaderExplodeVolumes::geometryShaderText =
"uniform float explodeV;\n"
"uniform float explodeF;\n"
"uniform mat4 ModelViewProjectionMatrix;\n"
"uniform mat4 NormalMatrix;\n"
"uniform mat4 ModelViewMatrix;\n"
"uniform vec3 lightPosition;\n"
"\n"
"uniform vec4 ambient;\n"
"uniform vec4 backColor;\n"
"uniform vec4 plane;\n"
"\n"
"VARYING_IN vec3 colorVertex[4];\n"
"VARYING_OUT vec4 ColorFS;\n"
"\n"
"\n"
"void main(void)\n"
"{\n"
"	float d = dot(plane,POSITION_IN(0));\n"
"	\n"
"	if (d<=0.0)\n"
"	{\n"
"		vec3 v1 = POSITION_IN(2).xyz - POSITION_IN(1).xyz;\n"
"		vec3 v2 = POSITION_IN(3).xyz - POSITION_IN(1).xyz;\n"
"		vec3 N  = cross(v1,v2);\n"
"		N = normalize (vec3(NormalMatrix*vec4(N,0.0))); \n"
"		\n"
"	// compute face center & lighting informations\n"
"		vec4 newPos =  ModelViewMatrix * vec4(colorVertex[0],1.0);\n"
"		vec3 L =  normalize (lightPosition - newPos.xyz);\n"
"		float lambertTerm = dot(N,L);\n"
"	\n"
"		for (int i=1; i<=3; i++)\n"
"		{\n"
"			// explode in face\n"
"			vec4 P = explodeF * POSITION_IN(i)  + (1.0-explodeF)* vec4(colorVertex[0],1.0);\n"
"\n"
"			// explode in volume\n"
"			vec4 Q = explodeV *  P + (1.0-explodeV)* POSITION_IN(0);\n"
"			gl_Position = ModelViewProjectionMatrix *  Q;\n"
"			if (lambertTerm > 0.0)\n"
"				ColorFS = ambient + vec4(colorVertex[i]*lambertTerm, 1.0);\n"
"			else\n"
"				ColorFS = ambient - backColor*lambertTerm;\n"
"			EmitVertex();\n"
"		}\n"
"		EndPrimitive();\n"
"	}\n"
"}\n";

