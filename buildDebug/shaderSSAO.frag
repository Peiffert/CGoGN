std::string ShaderSSAO::fragmentShaderText =
"\n"
"PRECISON;\n"
"VARYING_FRAG vec2 texCoord;\n"
"uniform sampler2D FBOTextureNormal;\n"
"\n"
"const int MAX_KERNEL_SIZE = 128;\n"
"/******Taille du noyau unitaire (en nombre de points tests)******/\n"
"uniform int uKernelSize;\n"
"/******Points du noyau******/\n"
"uniform vec3 uKernelOffsets[MAX_KERNEL_SIZE];\n"
"/****** Rayon du noyau unitaire ******/\n"
"uniform float uRadius;// = 1.5\n"
"/****** Puissance de l'occlusion ******/\n"
"uniform float uPower;// = 2.0\n"
"FRAG_OUT_DEF;\n"
"\n"
"void main()\n"
"{\n"
"    gl_FragColor = texture2D(FBOTextureNormal, texCoord);\n"
"    // Normal and depth from uniform texture\n"
"    vec3 vNormal = vec3 (texture2D(FBOTextureNormal, texCoord));\n"
"    float depth = texture2D(FBOTextureNormal, texCoord)[3];\n"
"\n"
"    // Rotation matrix\n"
"    vec3 vZ = vec3(0.0,0.0,1.0);\n"
"    vec3 vRot = cross(vZ, vNormal);\n"
"    float aRot = acos(dot(vZ, vNormal));\n"
"    mat3 mRot = mat3(\n"
"        vRot[0]*vRot[0]+(1.0-vRot[0])*cos(aRot), vRot[0]*vRot[1]*(1.0-cos(aRot))-vRot[2]*sin(aRot), vRot[0]*vRot[2]*(1.0-cos(aRot))+vRot[1]*sin(aRot),\n"
"        vRot[0]*vRot[1]*(1.0-cos(aRot))+vRot[2]*sin(aRot), vRot[1]+(1.0-vRot[1]*vRot[1])*cos(aRot), vRot[1]*vRot[2]*(1.0-cos(aRot))-vRot[0]*sin(aRot),\n"
"        vRot[0]*vRot[2]*(1.0-cos(aRot))-vRot[1]*sin(aRot), vRot[1]*vRot[2]*(1.0-cos(aRot))+vRot[0]*sin(aRot), vRot[2]*vRot[2]+(1.0-vRot[2]*vRot[2])*cos(aRot)\n"
"        );\n"
"\n"
"    // Scale matrix\n"
"    float scale = uRadius/texCoord[0]; // /depth ??\n"
"    mat3 mScale = mat3(scale);\n"
"\n"
"    //Position on screen\n"
"    //vec2 position = 2*texCoord -vec2(1,1); NOT NEEDED\n"
"\n"
"    float occlusion = 0.0;\n"
"\n"
"    //For each point of the half-sphere\n"
"    for (int i = 0; i < uKernelSize; i++) {\n"
"        //Compute its location\n"
"        //vec3 samplePoint = position + mRot * mScale * uKernelOffsets[i]; NOT NEEDED\n"
"        //Compute equivalent coordinates on depth texture NOT NEEDED\n"
"        //vec3 positionOnTexture =  2*texCoord -vec2(1,1); NOT NEEDED\n"
"        vec3 samplePoint = vec3(texCoord,0) + mRot * mScale * uKernelOffsets[i];\n"
"        //bvec  = lessThan(samplePoint, vec3(1.0,1.0,0.0));\n"
"        //bvec  = lessThan(samplePoint, vec3(1.0,1.0,0.0));\n"
"        //if(samplePoint[0]<1.0 && samplePoint[1]<1.0 && samplePoint[0]>0.0 && samplePoint[1]>0.0)\n"
"        //{\n"
"            //Depth on the texture at the sample position\n"
"            float depth = 0.0;//texture2D(FBOTextureNormal, vec2(samplePoint[0],samplePoint[1]))[3];\n"
"            samplePoint[2] = 1.0;\n"
"            if(depth<samplePoint[2])\n"
"            {\n"
"                //occlusion = 1.0;\n"
"                occlusion = occlusion + 1.0/float(uKernelSize);\n"
"            }\n"
"        //}\n"
"    }\n"
"\n"
"    //gl_FragColor = vec4((vNormal[0]+1.0)/2.0*(1.0-occlusion),(vNormal[1]+1.0)/2.0*(1.0-occlusion),(vNormal[2]+1.0)/2.0*(1.0-occlusion),0.0);\n"
"    gl_FragColor = vec4((vNormal[0]+1.0)/2.0,(vNormal[1]+1.0)/2.0,(vNormal[2]+1.0)/2.0,0.0);\n"
"}\n";

